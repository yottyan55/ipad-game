<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Chase & Cheese</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0b0f; overflow:hidden; touch-action:none; }
    #wrap { position:fixed; inset:0; }
    canvas { width:100%; height:100%; display:block; }

    .hud {
      position: fixed; left: 12px; top: 12px; z-index: 5;
      color: #f2f2ff;
      font: 700 14px/1.2 system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.14);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(6px);
      user-select:none; -webkit-user-select:none;
    }
    .hud small { opacity:.85; font-weight:600; }

    .overlay {
      position: fixed; inset:0; z-index: 10;
      display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      padding: 22px;
      user-select:none; -webkit-user-select:none;
    }
    .card {
      width:min(640px, 92vw);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(20,20,30,.70);
      padding: 18px 18px 14px;
      box-shadow: 0 16px 48px rgba(0,0,0,.45);
      color:#f2f2ff;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
    }
    .title { font-size:22px; font-weight:900; margin-bottom:6px; }
    .desc { opacity:.92; font-weight:650; line-height:1.6; }
    .btns { display:flex; gap:10px; justify-content:center; margin-top:14px; flex-wrap:wrap; }
    button {
      appearance:none;
      border: 1px solid rgba(255,255,255,.18);
      color:#f2f2ff;
      background: rgba(255,255,255,.10);
      padding: 10px 14px;
      border-radius: 12px;
      font: 800 14px system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      cursor:pointer;
    }
    button:active { transform: translateY(1px); }
    .note { margin-top:10px; opacity:.75; font-weight:650; font-size:13px; }
    .warn { margin-top:10px; opacity:.95; font-weight:800; font-size:13px; color:#ffe8a3; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="c"></canvas></div>

  <div class="hud" id="hud">
    スコア: <span id="score">0</span>　レベル: <span id="lvl">1</span><br/>
    <small>操作：画面を押したまま動かす（指の方向へネズミが移動）</small>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <div class="title">Chase &amp; Cheese</div>
      <div class="desc">
        ネズミ役でチーズを集めよう。猫に触れられると小さくなる。<br/>
        チーズを<b>10個</b>食べると<b>鬼モード</b>に変身。猫が泣きながら逃げるので追いかけよう。
      </div>
      <div class="btns">
        <button id="startBtn">スタート</button>
        <button id="howBtn">遊び方</button>
      </div>
      <div class="note">
        同じフォルダに置く：<br/>
        <b>cat_sprite.png / mouse_sprite.png / mouse_rage.png / cat_scared.png / cat_cry.png</b>
      </div>
      <div class="warn" id="assetWarn" style="display:none;">
        画像が読み込めていません。ファイル名（大文字/小文字含む）を確認してください。
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const scoreEl = document.getElementById("score");
  const lvlEl = document.getElementById("lvl");
  const overlay = document.getElementById("overlay");
  const startBtn = document.getElementById("startBtn");
  const howBtn = document.getElementById("howBtn");
  const assetWarn = document.getElementById("assetWarn");

  // ----- Scaling (fix: iPad looked small because DPR>1) -----
  // We keep positions in device pixels (DPR space), and scale character sizes by (DPR * touchBoost).
  let DPR = 1;
  let SCALE = 1; // size scale in device pixels
  function computeScale(dpr){
    const coarse = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
    const touchBoost = coarse ? 1.25 : 1.0; // iPad/phone -> a bit bigger than PC
    return dpr * touchBoost;
  }

  // Base sizes (in "PC CSS px" sense; will be multiplied by SCALE)
  const BASE = {
    mouseR: 26,
    catR: 34,
    cheeseR: 13,
    growStep: 1.2,
    shrinkStep: 4.0,
    rMin: 18,
    rMax: 60,
  };

  // HiDPI resize
  function resize() {
    const newDpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const w = Math.floor(rect.width * newDpr);
    const h = Math.floor(rect.height * newDpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
    }
    DPR = newDpr;
    SCALE = computeScale(DPR);
  }
  new ResizeObserver(resize).observe(canvas);
  window.addEventListener("orientationchange", () => setTimeout(resize, 200));

  // Assets (same folder)
  const ASSETS = {
    mouse: new Image(),
    cat: new Image(),
    mouse_rage: new Image(),
    cat_scared: new Image(),
    cat_cry: new Image(),
  };
  ASSETS.mouse.src      = "mouse_sprite.png";
  ASSETS.cat.src        = "cat_sprite.png";
  ASSETS.mouse_rage.src = "mouse_rage.png";
  ASSETS.cat_scared.src = "cat_scared.png";
  ASSETS.cat_cry.src    = "cat_cry.png";

  function isLoaded(img){
    return img && img.complete && img.naturalWidth > 0;
  }

  // Helpers
  const rnd = (a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  // Game state
  const state = {
    running:false,
    gameOver:false,
    t:0,
    score:0,
    level:1,
    cheesesEaten: 0,          // ★チーズ累計（変身判定用）
    target:null,
    lastCheeseAt:0,
    cheeses:[],
    fx:[],
    rage: { active:false, t:0, duration: 7.0, nextAt: 10 }, // ★10個で鬼モード（次は+10で再発動）
    mouse:{ x:0, y:0, r:26, speed: 520, face: 1, rMin: 18, rMax: 60, growStep: 1.2, shrinkStep: 4.0, invuln: 0 },
    cat:{ x:0, y:0, r:34, speed: 360, face: 1 },
  };

  function applyScaledParams(){
    // sizes in device pixels
    state.mouse.rMin = BASE.rMin * SCALE;
    state.mouse.rMax = BASE.rMax * SCALE;
    state.mouse.growStep = BASE.growStep * SCALE;
    state.mouse.shrinkStep = BASE.shrinkStep * SCALE;

    state.cat.r = BASE.catR * SCALE;

    // ensure current mouse r stays within bounds after scaling changes
    state.mouse.r = clamp(state.mouse.r, state.mouse.rMin, state.mouse.rMax);
  }

  function updateHUD(){
    scoreEl.textContent = String(state.score);
    lvlEl.textContent = String(state.level);
  }

  function reset(){
    resize();
    applyScaledParams();

    const W = canvas.width, H = canvas.height;

    state.running = false;
    state.gameOver = false;
    state.t = 0;
    state.score = 0;
    state.level = 1;
    state.cheesesEaten = 0;
    state.target = null;
    state.lastCheeseAt = 0;

    state.rage.active = false;
    state.rage.t = 0;
    state.rage.nextAt = 10;

    // start sizes (scaled)
    state.mouse.r = BASE.mouseR * SCALE;
    state.mouse.invuln = 0;
    state.mouse.face = 1;

    state.mouse.x = W*0.25;
    state.mouse.y = H*0.58;

    state.cat.x = W*0.78;
    state.cat.y = H*0.45;
    state.cat.face = -1;

    state.cheeses.length = 0;
    state.fx.length = 0;
    for (let i=0;i<4;i++) spawnCheese();
    updateHUD();
  }

  function cheeseRadius(){
    return BASE.cheeseR * SCALE;
  }

  function spawnCheese(){
    const W = canvas.width, H = canvas.height;
    const r = cheeseRadius();
    let x,y;
    for (let tries=0; tries<60; tries++){
      x = rnd(50, W-50);
      y = rnd(90, H-50);
      const dx = x - state.cat.x;
      const dy = y - state.cat.y;
      if (Math.hypot(dx,dy) > 140) break;
    }
    state.cheeses.push({ x, y, r });
  }

  // Input (pointer works for touch & mouse)
  function pointerPos(e){
    const rect = canvas.getBoundingClientRect();
    const dpr = canvas.width / rect.width; // == DPR
    return { x:(e.clientX-rect.left)*dpr, y:(e.clientY-rect.top)*dpr };
  }
  let down = false;

  function onDown(e){
    down = true;
    state.target = pointerPos(e);
  }
  function onMove(e){
    if (!down) return;
    state.target = pointerPos(e);
  }
  function onUp(){
    down = false;
    state.target = null;
  }

  canvas.addEventListener("pointerdown", (e)=>{ canvas.setPointerCapture(e.pointerId); onDown(e); });
  canvas.addEventListener("pointermove", onMove);
  canvas.addEventListener("pointerup", onUp);
  canvas.addEventListener("pointercancel", onUp);

  // Prevent scroll/gesture interference on iPad
  document.addEventListener("touchmove", (e)=>e.preventDefault(), { passive:false });

  // Main loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if (state.running) step(dt);
    draw();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function step(dt){
    resize();
    applyScaledParams();
    state.t += dt;

    // Level up by score
    const lvl = 1 + Math.floor(state.score / 8);
    if (lvl !== state.level) {
      state.level = lvl;
      updateHUD();
    }

    const W = canvas.width, H = canvas.height;
    const M = state.mouse;
    const C = state.cat;

    // invulnerability timer
    if (M.invuln > 0) M.invuln = Math.max(0, M.invuln - dt);

    // ---- Rage mode start/end (trigger by cheeses eaten: 10) ----
    if (!state.rage.active && state.cheesesEaten >= state.rage.nextAt) {
      state.rage.active = true;
      state.rage.t = 0;
      state.rage.nextAt += 10; // 次の変身も10個ごと（不要ならこの行を消す）

      // 猫を少し離す（即接触を避ける）
      C.x = clamp(C.x + (Math.random()<0.5 ? -160 : 160), C.r, W - C.r);
      C.y = clamp(C.y + (Math.random()<0.5 ? -110 : 110), 70 + C.r, H - C.r);
    }

    if (state.rage.active) {
      state.rage.t += dt;
      if (state.rage.t >= state.rage.duration) {
        state.rage.active = false;
        state.rage.t = 0;
        // 終了時に少し戻す
        M.r = Math.max(M.rMin, M.r - (6 * SCALE));
      }
    }

    // Move mouse toward target
    const mSpeed = M.speed * (1 + (state.level-1) * 0.03);
    if (state.target){
      const dx = state.target.x - M.x;
      const dy = state.target.y - M.y;

      // face update (left/right)
      if (Math.abs(dx) > 2) M.face = dx >= 0 ? 1 : -1;

      const d = Math.hypot(dx,dy);
      if (d > 2){
        M.x += (dx/d) * mSpeed * dt;
        M.y += (dy/d) * mSpeed * dt;
      }
    }
    M.x = clamp(M.x, M.r, W - M.r);
    M.y = clamp(M.y, 70 + M.r, H - M.r);

    // Move cat: normal = chase / rage = run away
    const baseCSpeed = C.speed * (1 + (state.level-1) * 0.10);

    if (!state.rage.active) {
      // 猫がネズミを追う（通常）
      const dx = M.x - C.x;
      const dy = M.y - C.y;

      if (Math.abs(dx) > 2) C.face = dx >= 0 ? 1 : -1;

      const d = Math.hypot(dx,dy) || 1;
      C.x += (dx/d) * baseCSpeed * dt;
      C.y += (dy/d) * baseCSpeed * dt;
    } else {
      // 猫が泣きながら逃げる（鬼モード）
      const runSpeed = baseCSpeed * 1.35;
      const dx = C.x - M.x;
      const dy = C.y - M.y;

      if (Math.abs(dx) > 2) C.face = dx >= 0 ? 1 : -1;

      const d = Math.hypot(dx,dy) || 1;

      // 逃げる + 少し蛇行（コミカル）
      const wobble = Math.sin(state.t * 10) * 0.25;
      const nx = (dx/d) + wobble * (-(dy/d));
      const ny = (dy/d) + wobble * ( (dx/d));

      C.x += nx * runSpeed * dt;
      C.y += ny * runSpeed * dt;
    }

    C.x = clamp(C.x, C.r, W - C.r);
    C.y = clamp(C.y, 70 + C.r, H - C.r);

    // Spawn cheeses
    const spawnEvery = Math.max(0.65, 1.4 - state.level * 0.06);
    if (state.t - state.lastCheeseAt > spawnEvery){
      state.lastCheeseAt = state.t;
      if (state.cheeses.length < 10) spawnCheese();
    }

    // Collisions: mouse vs cheese
    for (let i = state.cheeses.length - 1; i >= 0; i--){
      const ch = state.cheeses[i];
      if (Math.hypot(M.x - ch.x, M.y - ch.y) < M.r + ch.r){
        state.cheeses.splice(i, 1);

        state.score += 1;
        state.cheesesEaten += 1; // ★変身のカウント

        // grow a bit
        M.r = Math.min(M.rMax, M.r + M.growStep);

        updateHUD();

        // small pushback on cat
        const pdx = C.x - M.x, pdy = C.y - M.y;
        const pd = Math.hypot(pdx,pdy) || 1;
        C.x += (pdx/pd) * (28 * SCALE);
        C.y += (pdy/pd) * (28 * SCALE);

        // sparkle fx
        for (let k=0;k<8;k++){
          state.fx.push({
            x: M.x, y: M.y,
            vx: (Math.random()*2-1)*220,
            vy: (Math.random()*2-1)*220,
            life: 0.35
          });
        }
      }
    }

    // Update fx
    for (let i=state.fx.length-1; i>=0; i--){
      const p = state.fx[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.92; p.vy *= 0.92;
      if (p.life <= 0) state.fx.splice(i,1);
    }

    // Contact handling (normal vs rage)
    if (!state.rage.active) {
      // 通常：猫がネズミを捕まえる → ネズミ小さく
      const catchDist = M.r + C.r * 0.75;
      if (M.invuln <= 0 && Math.hypot(M.x - C.x, M.y - C.y) < catchDist) {
        M.r = Math.max(M.rMin, M.r - M.shrinkStep);

        const dx = M.x - C.x, dy = M.y - C.y;
        const d = Math.hypot(dx,dy) || 1;
        M.x += (dx/d) * (40 * SCALE);
        M.y += (dy/d) * (40 * SCALE);

        M.invuln = 0.9;

        if (M.r <= M.rMin + 0.01) doGameOver();
      }
    } else {
      // 鬼：ネズミが猫に追いつく → ボーナス、鬼解除
      const hitDist = M.r * 0.85 + C.r * 0.75;
      if (Math.hypot(M.x - C.x, M.y - C.y) < hitDist) {
        state.score += 5;
        updateHUD();

        state.rage.active = false;
        state.rage.t = 0;

        // ちょい収束
        M.r = Math.max(M.rMin, M.r - (10 * SCALE));

        // 猫を逃がす
        C.x = W * 0.78;
        C.y = H * 0.45;
      }
    }
  }

  function doGameOver(){
    state.running = false;
    state.gameOver = true;

    overlay.innerHTML = `
      <div class="card">
        <div class="title">ゲームオーバー</div>
        <div class="desc">
          スコア：<b>${state.score}</b>　レベル：<b>${state.level}</b><br/>
          チーズ：<b>${state.cheesesEaten}</b>
        </div>
        <div class="btns">
          <button id="retryBtn">もう一回</button>
          <button id="closeBtn">閉じる</button>
        </div>
        <div class="note">チーズ10個で鬼モード。猫が逃げるので追いかけて逆転。</div>
      </div>
    `;
    overlay.style.display = "flex";

    document.getElementById("retryBtn").onclick = () => {
      reset();
      state.running = true;
      overlay.style.display = "none";
      rebuildStartOverlay();
    };
    document.getElementById("closeBtn").onclick = () => {
      overlay.style.display = "none";
    };
  }

  // Drawing
  function draw(){
    resize();
    applyScaledParams();
    const W = canvas.width, H = canvas.height;

    // Background
    const g = ctx.createRadialGradient(W*0.5, H*0.35, 10, W*0.5, H*0.5, Math.max(W,H));
    g.addColorStop(0, "#1c1c2a");
    g.addColorStop(1, "#0b0b0f");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // Top bar
    ctx.fillStyle = "rgba(255,255,255,0.05)";
    ctx.fillRect(0, 0, W, 66);
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.beginPath(); ctx.moveTo(0,66); ctx.lineTo(W,66); ctx.stroke();

    // Sparkles
    for (const p of state.fx){
      ctx.globalAlpha = Math.max(0, p.life / 0.35);
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3.2 * SCALE, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Cheeses
    for (const ch of state.cheeses) drawCheese(ch.x, ch.y, ch.r);

    // Cat selection (normal / scared / cry)
    let catImg = ASSETS.cat;
    if (state.rage.active) {
      catImg = (state.rage.t < 0.6) ? ASSETS.cat_scared : ASSETS.cat_cry;
    }
    drawSprite(catImg, state.cat.x, state.cat.y, state.cat.r, state.cat.face);

    // Mouse selection (normal / rage) + blink if invulnerable
    const mouseImg = state.rage.active ? ASSETS.mouse_rage : ASSETS.mouse;

    if (state.mouse.invuln > 0) {
      const blink = Math.floor(performance.now() / 90) % 2;
      if (blink === 0) {
        drawSprite(mouseImg, state.mouse.x, state.mouse.y, state.mouse.r, state.mouse.face);
      }
    } else {
      drawSprite(mouseImg, state.mouse.x, state.mouse.y, state.mouse.r, state.mouse.face);
    }

    // Target ring
    if (state.target){
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 2 * SCALE;
      ctx.beginPath();
      ctx.arc(state.target.x, state.target.y, 18 * SCALE, 0, Math.PI*2);
      ctx.stroke();
    }

    // Asset warning (start screen only)
    if (!state.running && !state.gameOver){
      const ok =
        isLoaded(ASSETS.mouse) &&
        isLoaded(ASSETS.cat) &&
        isLoaded(ASSETS.mouse_rage) &&
        isLoaded(ASSETS.cat_scared) &&
        isLoaded(ASSETS.cat_cry);
      assetWarn.style.display = ok ? "none" : "block";
    }
  }

  function drawSprite(img, x, y, r, face){
    const h = r * 2;

    // shadow
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.beginPath();
    ctx.ellipse(x, y + r*0.60, r*0.95, r*0.45, 0, 0, Math.PI*2);
    ctx.fillStyle = "#000";
    ctx.fill();
    ctx.restore();

    if (isLoaded(img)){
      const aspect = img.naturalWidth / img.naturalHeight;
      const w = h * aspect;

      ctx.save();
      ctx.translate(x, y);
      if (face === -1) ctx.scale(-1, 1);
      ctx.drawImage(img, -w/2, -h/2, w, h);
      ctx.restore();
    } else {
      ctx.fillStyle = "rgba(255,255,255,0.25)";
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
    }
  }

  function drawCheese(x,y,r){
    // vector cheese
    ctx.save();
    ctx.translate(x,y);

    // shadow
    ctx.globalAlpha = 0.18;
    ctx.beginPath();
    ctx.ellipse(0, r*0.9, r*0.8, r*0.35, 0, 0, Math.PI*2);
    ctx.fillStyle = "#000";
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = "#e7c85a";
    ctx.beginPath();
    ctx.moveTo(-r, r*0.9);
    ctx.lineTo(-r, -r*0.6);
    ctx.lineTo( r, 0);
    ctx.lineTo(-r, r*0.9);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "rgba(0,0,0,0.12)";
    for (let i=0;i<3;i++){
      const hx = rnd(-r*0.35, r*0.25);
      const hy = rnd(-r*0.25, r*0.35);
      const hr = rnd(r*0.10, r*0.20);
      ctx.beginPath(); ctx.arc(hx,hy,hr,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function rebuildStartOverlay(){
    overlay.innerHTML = `
      <div class="card">
        <div class="title">Chase &amp; Cheese</div>
        <div class="desc">
          ネズミ役でチーズを集めよう。猫に触れられると小さくなる。<br/>
          チーズを<b>10個</b>食べると<b>鬼モード</b>に変身。猫が逃げるので追いかけよう。
        </div>
        <div class="btns">
          <button id="startBtn">スタート</button>
          <button id="howBtn">遊び方</button>
        </div>
        <div class="note">
          同じフォルダに：<b>cat_sprite.png / mouse_sprite.png / mouse_rage.png / cat_scared.png / cat_cry.png</b>
        </div>
        <div class="warn" id="assetWarn" style="display:none;">
          画像が読み込めていません。ファイル名（大文字/小文字含む）を確認してください。
        </div>
      </div>
    `;
    document.getElementById("startBtn").onclick = () => {
      reset();
      state.running = true;
      overlay.style.display = "none";
    };
    document.getElementById("howBtn").onclick = () => showHow();
  }

  function showHow(){
    overlay.innerHTML = `
      <div class="card">
        <div class="title">遊び方</div>
        <div class="desc">
          1) 画面を押したまま指を動かす → ネズミが追従<br/>
          2) チーズを拾う → スコア増 & ネズミが少し大きくなる<br/>
          3) 猫に触れる → ネズミが少し小さくなる（小さくなりすぎると負け）<br/>
          4) チーズ<b>10個</b>で<b>鬼モード</b>：猫が泣きながら逃げる → 追いつくとボーナス
        </div>
        <div class="btns">
          <button id="backBtn">戻る</button>
        </div>
        <div class="note">
          反映されないときはURL末尾に <code>?v=数字</code> を付けて開く（キャッシュ回避）。
        </div>
      </div>
    `;
    overlay.style.display = "flex";
    document.getElementById("backBtn").onclick = () => location.reload();
  }

  // Wire buttons (initial)
  startBtn.onclick = () => {
    reset();
    state.running = true;
    overlay.style.display = "none";
  };
  howBtn.onclick = () => showHow();

  // Initialize
  reset();
})();
</script>
</body>
</html>
